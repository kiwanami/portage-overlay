Index: 085/org/Do.Platform/Makefile.am
===================================================================
--- 085.orig/org/Do.Platform/Makefile.am
+++ 085/org/Do.Platform/Makefile.am
@@ -59,6 +59,7 @@ FILES = \
 	src/Do.Platform/Services.cs \
 	src/Do.Platform/INetworkService.cs \
 	src/Do.Platform/NetworkStateChangedEventArgs.cs \
+	src/Do.Platform/Migemo.cs \
 	src/Do.Platform/IKeyBindingService.cs \
 	src/Do.Platform/KeyBinding.cs \
 	src/Do.Universe/Do.Universe.Common/EmailAction.cs \
Index: 085/org/Do.Platform/src/Do.Platform/Migemo.cs
===================================================================
--- /dev/null
+++ 085/org/Do.Platform/src/Do.Platform/Migemo.cs
@@ -0,0 +1,198 @@
+// vim:set ts=4 sts=4 sw=4 tw=0:
+
+using System;
+using System.Runtime.InteropServices;
+using System.Text.RegularExpressions;
+
+namespace KaoriYa.Migemo
+{
+	public class Migemo : IDisposable
+	{
+#region Enumerations (from migemo.h)
+#region enum OperatorIndex
+		public enum DictionaryId
+		{
+			Invalid		= 0,
+			Migemo		= 1,
+			RomaToHira	= 2,
+			HiraToKata	= 3,
+			HanToZen	= 4,
+		}
+#endregion
+
+#region enum OperatorIndex
+		public enum OperatorIndex
+		{
+			Or			= 0,
+			NestIn		= 1,
+			NestOut		= 2,
+			SelectIn	= 3,
+			SelectOut	= 4,
+			NewLine		= 5,
+		}
+#endregion
+#endregion
+
+#region Link to migemo.dll
+		[DllImport("migemo.dll")]
+		private static extern IntPtr migemo_open(string dict);
+		[DllImport("migemo.dll")]
+		private static extern void migemo_close(IntPtr obj);
+		[DllImport("migemo.dll")]
+		private static extern IntPtr migemo_query(IntPtr obj, string query);
+		[DllImport("migemo.dll")]
+		private static extern void migemo_release(IntPtr obj, IntPtr result);
+
+		[DllImport("migemo.dll")]
+		private static extern int migemo_set_operator(IntPtr obj,
+				OperatorIndex index, string op);
+		[DllImport("migemo.dll")]
+		private static extern IntPtr migemo_get_operator(IntPtr obj,
+				OperatorIndex index);
+
+		[DllImport("migemo.dll")]
+		private static extern DictionaryId migemo_load(IntPtr obj,
+				DictionaryId id, string file);
+		[DllImport("migemo.dll")]
+		private static extern int migemo_is_enable(IntPtr obj);
+#endregion
+
+		private IntPtr migemoObject = IntPtr.Zero;
+
+		public IntPtr MigemoObject
+		{
+			get
+			{
+				return this.migemoObject;
+			}
+		}
+
+		public bool SetOperator(OperatorIndex index, string op)
+		{
+			return migemo_set_operator(this.migemoObject, index, op) != 0;
+		}
+		public string GetOperator(OperatorIndex index)
+		{
+			IntPtr result = migemo_get_operator(this.migemoObject, index);
+			if (result != IntPtr.Zero)
+				return Marshal.PtrToStringAnsi(result);
+			else
+				return "";
+		}
+
+#region Operator properties
+		public string OperatorOr {
+			get { return GetOperator(OperatorIndex.Or); }
+			set { SetOperator(OperatorIndex.Or, value); }
+		}
+		public string OperatorNestIn {
+			get { return GetOperator(OperatorIndex.NestIn); }
+			set { SetOperator(OperatorIndex.NestIn, value); }
+		}
+		public string OperatorNestOut {
+			get { return GetOperator(OperatorIndex.NestOut); }
+			set { SetOperator(OperatorIndex.NestOut, value); }
+		}
+		public string OperatorSelectIn {
+			get { return GetOperator(OperatorIndex.SelectIn); }
+			set { SetOperator(OperatorIndex.SelectIn, value); }
+		}
+		public string OperatorSelectOut {
+			get { return GetOperator(OperatorIndex.SelectOut); }
+			set { SetOperator(OperatorIndex.SelectOut, value); }
+		}
+		public string OperatorNewLine {
+			get { return GetOperator(OperatorIndex.NewLine); }
+			set { SetOperator(OperatorIndex.NewLine, value); }
+		}
+#endregion
+
+		public bool LoadDictionary(DictionaryId id, string file)
+		{
+			DictionaryId result = migemo_load(this.migemoObject, id, file);
+			return result == id;
+		}
+
+		public bool IsEnable()
+		{
+			return migemo_is_enable(this.migemoObject) != 0;
+		}
+
+		public Regex GetRegex(string query)
+		{
+			return new Regex(Query(query));
+		}
+
+		public string Query(string query)
+		{
+			IntPtr result = migemo_query(this.migemoObject, query);
+			if (result != IntPtr.Zero)
+			{
+				string retval = Marshal.PtrToStringAnsi(result);
+				migemo_release(this.migemoObject, result);
+				return retval;
+			}
+			else
+				return "";
+		}
+
+		public void Dispose()
+		{
+			//Console.WriteLine("HERE ("+this.migemoObject+")");
+			if (this.migemoObject != IntPtr.Zero)
+			{
+				//Console.WriteLine("migemo_close() is called");
+				migemo_close(this.migemoObject);
+				this.migemoObject = IntPtr.Zero;
+			}
+		}
+
+		public Migemo(string dictpath)
+		{
+			this.migemoObject = migemo_open(dictpath);
+			this.OperatorNestIn = "(?:";
+			//this.OperatorNewLine = "\\s*";
+		}
+
+		public Migemo() : this(null)
+		{
+		}
+
+#region Test entrypoint
+#if TEST_MIGEMO
+		// ƒeƒXƒgŠÖ”
+		public static int Main(string[] args)
+		{
+			Migemo m;
+
+			if (args.Length > 0)
+			{
+				m = new Migemo(args[0]);
+				Console.WriteLine("Migemo object is initialized with "
+						+args[0]);
+			}
+			else
+			{
+				m = new Migemo();
+				Console.WriteLine("Migemo object is initialized");
+			}
+			Console.WriteLine("MigemoObject="+m.MigemoObject);
+
+			string result = m.Query("ao");
+			Console.WriteLine("ai="+result);
+
+			OperatorIndex[] opall = {
+				OperatorIndex.Or, OperatorIndex.NestIn,
+				OperatorIndex.NestOut, OperatorIndex.SelectIn,
+				OperatorIndex.SelectOut, OperatorIndex.NewLine
+			};
+			foreach (OperatorIndex index in opall)
+				Console.WriteLine("OperatorIndex[{0}]={1}",
+						index, m.GetOperator(index));
+			return 0;
+		}
+#endif
+#endregion
+
+	}
+}
Index: 085/org/Do/src/Do.Core/RelevanceProvider.cs
===================================================================
--- 085.orig/org/Do/src/Do.Core/RelevanceProvider.cs
+++ 085/org/Do/src/Do.Core/RelevanceProvider.cs
@@ -23,6 +23,7 @@ using System.IO;
 using System.Collections.Generic;
 using System.Runtime.Serialization;
 using System.Runtime.Serialization.Formatters.Binary;
+using System.Text.RegularExpressions;
 
 using Do.Platform;
 using Do.Universe;
@@ -120,6 +121,9 @@ namespace Do.Core {
 			float score;
 			string ls = s.ToLower ();
 
+            score = tryMigemoMatch(s,query);
+            if (score > 0) return score;
+
 			//Find the shortest possible substring that matches the query
 			//and get the ration of their lengths for a base score
 			int[] match = findBestSubstringMatchIndices (ls, query);
@@ -169,6 +173,47 @@ namespace Do.Core {
 			return score;
 		}
 
+        private static KaoriYa.Migemo.Migemo migemo = new KaoriYa.Migemo.Migemo("/usr/share/migemo/migemo-dict");
+        private static string migemoLastQuery;
+        private static string migemoLastRegex;
+
+        public static string PrepareMigemoString(string str)
+        {
+            string ret = "";
+            bool upper = false;
+            foreach (char a in str) {
+                if (upper) {
+                    ret += a.ToString().ToUpper();
+                    upper = false;
+                } else if (a == ' ') {
+                    upper = true;
+                } else {
+                    ret += a;
+                }
+            }
+            return ret;
+        }
+
+        protected static float tryMigemoMatch(string s, string query)
+        {
+            if (query.Length < 3)
+                return 0f;
+            
+            if (migemoLastQuery != query) {
+                migemoLastQuery = query;
+                migemoLastRegex = migemo.Query(PrepareMigemoString(query));
+            }
+            if (migemoLastRegex == null)
+                return 0f;
+
+            Match match = Regex.Match(s, migemoLastRegex);
+            if (match.Value == "") 
+                return 0f;
+
+            return 0.9f + (float)(0.1f * match.Value.Length / s.Length);
+        }
+
+
 		/// <summary>
 		/// Finds the shortest substring of s that contains all the characters of query in order
 		/// </summary>
@@ -238,7 +283,8 @@ namespace Do.Core {
 
 		public virtual float GetRelevance (Item r, string match, Item other)
 		{
-			return StringScoreForAbbreviation (r.Safe.Name, match);
+            float a = StringScoreForAbbreviation (r.Safe.Name, match);
+			return a;
 		}
 	}
 }
Index: 085/org/Do.Interface.Linux/src/Do.Interface/Util.cs
===================================================================
--- 085.orig/org/Do.Interface.Linux/src/Do.Interface/Util.cs
+++ 085/org/Do.Interface.Linux/src/Do.Interface/Util.cs
@@ -20,6 +20,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Text.RegularExpressions;
 
 using Gdk;
 using Cairo;
@@ -36,8 +37,51 @@ namespace Do.Interface
 	
 	public static class Util
 	{
+        private static KaoriYa.Migemo.Migemo migemo = new KaoriYa.Migemo.Migemo("/usr/share/migemo/migemo-dict");
+
+        public static string PrepareMigemoString(string str)
+        {
+            string ret = "";
+            bool upper = false;
+            foreach (char a in str) {
+                if (upper) {
+                    ret += a.ToString().ToUpper();
+                    upper = false;
+                } else if (a == ' ') {
+                    upper = true;
+                } else {
+                    ret += a;
+                }
+            }
+            return ret;
+        }
+
 		public static string FormatCommonSubstrings (string main, string other, string format)
 		{
+            // try migemo
+            try {
+                if (other.Length >= 3) {
+                    string rx = migemo.Query(PrepareMigemoString(other));
+                    if (rx != null) {
+                        Match match = Regex.Match(main, rx);
+                        if (match.Value != "") {
+                            string skipped = main.Substring (0, match.Index);
+                            string matched = match.Value;
+                            string remainder = main.Substring(match.Index + match.Length);
+                            return string.Format ("{0}{1}{2}", skipped, 
+                                                  string.Format(format, matched), 
+                                                  remainder);
+                        }
+                    }
+                }
+            } catch (System.ArgumentException e) {
+                //do nothing
+            }
+            return FormatCommonSubstrings_rec(main,other,format);
+        }
+
+		private static string FormatCommonSubstrings_rec (string main, string other, string format)
+		{
 			int pos, len, match_pos, last_main_cut;
 			string lower_main, result;
 			string skipped, matched, remainder;
@@ -69,7 +113,7 @@ namespace Do.Interface
 					skipped = main.Substring (last_main_cut, match_pos - last_main_cut);
 					matched = main.Substring (match_pos, len);
 					if ( skipped.Length + matched.Length < main.Length) {
-						remainder = FormatCommonSubstrings ( main.Substring (match_pos + len), other.Substring (pos + len), format);
+						remainder = FormatCommonSubstrings_rec ( main.Substring (match_pos + len), other.Substring (pos + len), format);
 					}
 					else {
 						remainder = "";
